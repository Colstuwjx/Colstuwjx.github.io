---
title: "[ 翻译 ] "
date: 2021-08-08T10:00:00+08:00
tags: ["translate", "facebook", "mysql"]
categories: ["devops"]
comments: false
showMeta: false
showAction: false
---

【编者的话】本文讲述了 FaceBook 内部如何从 MySQL 5.6 迁移到 8.0。

<!--more-->

MySQL 是一款由 Oracle 公司开发维护的开源数据库, Facebook 一些最关键的工作负载均有赖于它来提供动力。我们积极地为 MySQL 开发新功能，以支持不断发展的业务需求。这些特性改变了 MySQL 的许多不同领域，包括客户端连接器、存储引擎、优化器和复制同步。每升级到 MySQL 新的主要版本都需要花费大量的时间和精力来迁移我们的工作负载。这些挑战包括：

* 将我们定制的一些功能移植到新版本

* 确保复制同步在主要版本之间的兼容性

* 让现有应用程序查询需要做的改动最小化

* 修复妨碍服务器支持线上工作负载的性能回归问题

我们上一次重大的版本升级，是升级到 MySQL 5.6，那一次用了一年多的时间才搞定。5.7 刚发布的时候，我们还在 5.6 版本上开发我们的 LSM-Tree 存储引擎 MyRocks 。由于升级到5.7，与此同时又建立一个新的存储引擎的话将会显著放缓 MyRocks 的开发进展，我们选择留在 5.6，直到 MyRocks 完成。MySQL 8.0 是在我们将 MyRocks 发布到用户数据库（ UDB ）服务层时宣布的。

该版本有着众多引人注目的特性，比如基于写集合的并行复制功能，以及一个提供原子性的 DDL 支持的事务数据字典。对我们来说，迁移到 8.0 也会为我们带来之前错过的一些 5.7 的特性，包括文档存储。5.6 版本已经接近尾声，我们希望在 MySQL 社区保持活跃，特别是在 MyRocks 存储引擎方面。8.0 里面的增强功能，比如即时 DDL ，可以加快 MyRocks 的表结构变更速度，但是我们需要在 8.0 代码库中使用它。考虑到代码更新的好处，我们决定迁移到 8.0 版本。我们将分享我们是如何解决 8.0 迁移项目 ———— 以及在此过程中我们发现的一些惊喜。当我们最初确定项目的范围时，很明显，迁移到 8.0 将会比迁移到 5.6 或 MyRocks 更加困难。

* 当时，我们定制的 5.6 分支有超过 1700 个代码补丁要移植到 8.0。在我们移植这些补丁的同时，新的 Facebook MySQL 特性和补丁被源源不断地添加到 5.6 的代码基中，让我们的目标变得更加遥远。

* 我们的生产环境里运行了大量的 MySQL 服务器，它们为各式各样的应用程序提供服务。我们也有管理大量 MySQL 实例的软件基础设施。这些应用程序执行收集统计信息和管理服务器备份等操作。

* 从 5.6 升级到 8.0 完全跳过了 5.7 版本。5.6 里的 Activity API 在 5.7 版本将会被弃用，而且可能在 8.0 里移除，这就要求我们把使用了已经移除 API 的这些应用程序更新到新版本。

* Facebook 用到的许多功能和 8.0 版本里的类似功能并不是向前兼容的，我们需要一个弃用和升级迁移的方案。

* 运行 8.0 版本需要一些 MyRocks 的增强特性，包括本机分区和崩溃恢复。

## 代码补丁

我们首先设置了 8.0 分支，以便在开发环境中构建和测试。然后，我们开始了一段漫长的旅程，在新分支上重新应用 5.6 上曾经打过的补丁。刚开始的时候我们有超过 1700 多个补丁，但是我们能够把它们分成几个大类。我们大多数定制的代码都有良好的注释和描述信息，因此我们可以很轻松地确认在后续的版本里应用程序是否仍然需要它，或者是否可以删掉。

由特殊关键字或唯一变量名开启的特性也很容易确定其相关性，我们可以在应用程序代码库搜索引用它们的地方。难免有一些搞不清楚具体用途的补丁，这时候就需要做一些调查工作：挖掘之前的设计文档、发过的帖子和/或代码审查注释来了解它们的历史。

我们将每个补丁分成四个 bucket ：

1、删除：在 8.0 版本里不再使用或者已经存在相同功能的特性，不需要移植；

2、 Build / Client ：一些非服务端特性，如一些用于支持我们的构建环境而且做了定制修改的 MySQL 工具，比如 mysqlbinlog，又或是添加了异步的客户端 API 这样的功能集，均会被移植到 8.0 版本；

3、非 MyRocks 服务器：我们为 mysqld 服务端移植了一些与 MyRocks 存储引擎无关的功能；

4、MyRocks 服务器：移植了一些支持 MyRocks 存储引擎的功能

我们使用电子表格跟踪每个补丁的状态和相关历史信息，并且在删除某个补丁时记录了相关的推理过程。用于更新同一功能的多个补丁将会被打包到一起进行移植。移植并提交到 8.0 分支的这些补丁，它们的提交信息里会带有 5.6 的注释。由于需要针对大量补丁做筛选，移植状态上的差异将不可避免地出现，这些注释帮助我们解决了这些问题。

每一组客户端和服务端会自然而然地成为一次软件发布的里程碑，通过移植所有和客户端相关的改动，我们得以将客户端工具和连接器代码更新到 8.0。一旦完成所有非 MyRocks 的服务端特性的移植工作，我们便可以为 InnoDB 服务器部署 8.0 版本的 mysqld 。而在完成了 MyRocks 相关服务器功能之后，我们就可以更新 MyRocks 的部署版本了。

某些最为复杂的功能特性可能要求我们对 8.0 做出一些重大的更改，而且会有一些区域存在重大的兼容性问题。举个例子，上游 8.0 的 binlog 事件格式和我们一些定制的 5.6 改动有不兼容的地方。在 Facebook 内部魔改后的 5.6 版本里用到的错误代码定义和上游 8.0 一些新功能分配的部分有冲突。我们最终需要给我们的 5.6 服务器打上一些补丁，使其能够和 8.0 向前兼容。

完成所有这些功能的移植需要几年时间。到最后，我们已经评估了 2300 多个补丁，并且将其中的 1500 个移植到了 8.0。

## 迁移之路

我们将多个 mysqld 实例组合成一个 MySQL 副本集。副本集中的每个实例包含相同的数据，但是在地理上会分布到不同的数据中心，以提供数据可用性和故障转移支持。每个副本集有一个主实例。其余的实例都是二级实例。主进程处理所有的写通信流，并将数据异步复制到所有的从进程。

我们从包含了 5.6 主和从的副本集出发，最终目标是迁移到 8.0 主和从的副本集。我们采用了和 UDB MyRocks 迁移计划相似的方案。

1. 对于每个副本集，我们会使用 mysqldump 通过一份逻辑副本创建和添加 8.0 的从服务。这些从服务不提供任何应用程序的读请求；

2. 在 8.0 的从服务上对外开放读请求；

3. 允许将 8.0 实例提升为主实例；

4. 关闭 5.6 实例的读请求；

5. 移除所有 5.6 实例。

每个副本集可以各自独立地流转上述步骤，并根据需要停留在某个阶段。我们将副本集划分成一些更小的组，然后引导它们完成各个转换。如果发现问题的话，我们可以回滚到上一步。在某些情况下，一些副本集能够在其他副本开始前就已经执行到了最后一步。

为了让这大量的副本集转换能够自动化，我们需要构建一套新的软件基础设施。我们可以将副本集分到一个组，然后通过简单地改动配置文件里的一行配置来切换。一旦遇到问题，任何副本集都可以单独执行回滚。

### 基于行的复制同步

作为 8.0 迁移工作的一部分，我们决定使用基于行的复制进行标准化（RBR）。8.0 的某些特性会需要用到 RBR，它简化了 MyRocks 的移植工作。虽然我们绝大部分的 MySQL 副本集已经使用了 RBR，但是那些仍然跑着基于语句的复制（SBR）的实例转换到 RBR 却没那么容易。这些副本集通常会有一些没有任何高基数键的表。完全切换到 RBR 曾经是我们的目标之一，但是需要添加主键的长尾工作，其优先级往往低于其他项目。

因此，我们对 8.0 做了必须是 RBR 的要求。在评估以及为每张表添加主键之后，我们在今年完成了最后一个 SBR 副本集的切换工作。使用 RBR 还为我们提供了一个解决某个应用程序问题的替代解决方案，我们在将一些副本集迁移到 8.0 主库的时候遇到了这个问题，稍后会详细介绍。

## 自动校验

大部分实例在迁移到 8.0 的过程中均涉及到利用我们的自动化基础设施和应用程序查询来测试和验证 mysqld 服务器。

随着 MySQL 实例数量的不断增长，我们用于管理服务器的自动化基础设施也在成长。为了确保我们实现的所有 MySQL 自动化操作在 8.0 版本都是兼容的，我们投资建设了一个测试环境，它会利用跑在虚拟机上的测试副本集来验证一些行为。我们编写了相关的集成测试，对每一块跑在 5.6 和 8.0 版本下的自动化任务进行跟踪，然后验证它们的正确性。在这个执行过程中，我们发现了一些 bug 和不一致的行为。

在对我们的 MySQL 基础设施里里外外都执行了一遍 8.0 服务器验证以后，我们发现并修复（或 workaround ）了不少有意思的问题：

1. 解析错误日志、mysqldump 输出或是服务端 show 命令的软件很容易崩溃。服务端输出的细微变化常常会引发工具的解析逻辑出现 bug ；

2. 8.0 默认采用的是 utf8mb4 字符集，这一设置导致我们的 5.6 实例和 8.0 实例字符集不匹配。8.0 的表可以使用新的 utf8mb4_0900 字符集设置规则，甚至对于 5.6 的 show create table 也是如此，因为 5.6 里面用到 utf8mb4_general_ci 的表结构没有显式地指定字符集。这些表的差异常常会导致同步复制和表结构校验工具出问题。

3. 某些同步复制失败时抛出的错误代码发生了变化，我们必须修复我们的自动化程序以正确处理它们；

4. 8.0 版本的数据字典淘汰了 table.frm 文件，但是我们的一些自动化程序仍然使用它们来检测表结构的更改；

5. 我们必须更新我们的自动化程序以支持在 8.0 中引入的动态权限功能。

## 应用层校验

我们希望对于应用程序来说，迁移过程尽可能是透明的，但是某些应用程序的查询在 8.0 上会出现性能递减甚至失败。

针对 MyRocks 实例的迁移工作，我们构建了一套 MySQL shadow 测试框架，它会捕获生产的流量然后在测试实例上重放。对于每个应用程序工作负载来说，我们在 8.0 上构建了测试实例，并重放了捕获的线上查询流量。我们收集并记录了从 8.0 服务端返回的报错，然后发现了一些有意思的问题。不幸的是，并非所有这些问题都是在测试过程中发现的。比如，在迁移期间有些应用程序出现了交易死锁。在研究如下问题的解决方案的同时，我们暂时先将这些应用程序回滚到使用 5.6 版本的实例。

* 8.0 里引入的一些新的保留关键字，其中少数（如 group 和 rank ）与应用查询中用到的热门的表、列名称或者别名冲突。这些查询语句里的表或者字段名称没有通过带上反引号规避冲突，导致解析报错。使用了自动给查询语句里的列名称打上反引号的软件库的那些应用程序则没有触发这个问题，但是并非所有应用都是这样。解决问题的办法很简单，但是需要花时间来追查生成这些查询的应用 owner 以及代码库；

* 在 5.6 和 8.0 版本之间也发现了一些 REGEXP 功能方面的不兼容；

* 5.6 版本的 InnoDB 有个 bug，小部分跑在上面然后又带有 insert ... on duplicate key 查询的应用程序触发了所谓的重复读事务的死锁问题，该问题在 8.0 得到了修复，但是这一修复增加了事务死锁的可能性。在分析了我们的查询后，我们选择的是通过降低隔离级别来解决这些问题。自从我们切换到基于行的复制以后，我们便可以使用该选项了；

* 我们自定义的 5.6 文档存储以及 JSON 函数在 8.0 不兼容。使用了文档存储的应用程序被要求将文档类型转换成文本然后再迁移。针对 JSON 函数，我们将一些 5.6 兼容的版本添加到了 8.0 服务端，以便应用程序后续找时间再迁移到 8.0 的 API。

我们在对 8.0 服务端的查询和性能测试的过程中发现了一些需要立即解决的问题：

* 围绕 ACL 缓存有一些新的互斥锁的竞争热点。在同时打开大量连接时，它们有可能都阻塞在 ACL 检查这一步；

* 当存在许多 binlog 文件以及高频率的 binlog 写操作导致轮换文件频繁时，我们在 binlog 的索引访问里也发现了类似的争抢；

* 一些有用到临时表的查询操作炸了。查询将返回未预料的错误，或者运行时间过长，以至于超时。

和 5.6 相比，迁移到 8.0 以后我们的内存使用量增加了，尤其是 MyRocks 的实例，因为 8.0 里面的 InnoDB 必须被加载。默认的 performance_schema 设置启用了大量的监控指标并消耗了大量的内存。我们限制了内存的使用，只保留了少量的指标，然后通过修改代码来禁用那些无法手动关闭的表。然而，并非多出来的内存都是用在 performance_schema 上。我们需要检查和修改各种 InnoDB 的内部数据结构，以进一步减少内存的占用。这一努力将 8.0 的内存使用量降低到了可接受的水准。

## 接下来

到目前为止，8.0 迁移已经花了好几年的时间。我们已经将许多 InnoDB 的复制集完全转换为在 8.0 上运行。剩下的绝大部分还处在迁移路上的不同阶段。如今，我们大部分的自定义功能都已经完成了 8.0 的移植工作，再去更新到 Oracle 发布的小版本相对已经比较容易了，我们计划跟上最新版本的步伐。

跳过像 5.7 这样的主要版本会引入一些问题，我们在迁移时也自然需要解决这些问题：

首先，我们不会就地升级服务端，而是要求使用逻辑转储以及还原来构建新的服务器。但是，对于非常大的 mysqld 实例来说，这可能需要实时地在生产服务器上跑很多天，而且这个过程中非常脆弱，在完成前很容易被打断。对于这些大的实例，我们就得修改备份还原的系统来支持重新构建。

其次，检测 API 更改要比想象的困难得多，因为 5.7 可能会向我们的应用程序客户端抛出弃用警告，要求我们修复潜在的问题。取而代之的是，我们需要在迁移生产的工作负载前执行额外的 shadow 测试来定位故障。如果使用了自动给 schema 对象的名字打上反引号的 mysql 客户端软件会有助于减少兼容性问题产生的数量。

在副本集里支持两个大版本是一件很困难的事情。一旦一个副本集把它的主实例升级到了 8.0，那么最好是尽快禁用和删掉之前的 5.6 实例。应用程序用户倾向于发掘一些仅由 8.0 提供支持的新功能，比如 utf8mb4_0900 字符集，使用这些功能的话可能会导致 8.0 到 5.6 版本的实例之间同步复制流中断。

尽管我们的迁移之路存在种种坎坷，但是我们已经看到运行 8.0 带来的很多好处。一些应用程序已经选择提前转换到 8.0 版本以便利用文档存储以及改进的 datetime 支持等功能。我们一直在考虑如何支持存储引擎功能，比如 MyRocks 上的 DDL。总体而言，升级到新版本很大程度上扩展了我们在 Facebook 使用到的 MySQL 的场景。
